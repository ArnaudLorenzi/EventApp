using EventApp.Model;
using EventApp.Presentation;
using EventApp.Service;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Threading.Tasks;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;

// Pour plus d'informations sur le modèle d'élément Page vierge, voir la page http://go.microsoft.com/fwlink/?LinkId=234238

namespace EventApp.Pages
{
    /// <summary>
    /// Une page vide peut être utilisée seule ou constituer une page de destination au sein d'un frame.
    /// </summary>
    public sealed partial class MyEvent : Page
    {
        private EventViewModel vm;
        private static double _persistedItemContainerHeight = -1;
        private static string _persistedItemKey = "";
        private static string _persistedPosition = "";

        public MyEvent()
        {
            this.InitializeComponent();
            // Page_Loaded calls the ListViewPersistenceHelper function to scroll to the last saved scroll position
            this.Loaded += Page_Loaded;

            vm = new EventViewModel();
            base.DataContext = vm;
        }

        /// <summary>
        ///     Invoked when this page is about to be displayed in a Frame.
        /// </summary>
        /// <param name="e">
        ///     Event data that describes how this page was reached.  The Parameter
        ///     property is typically used to configure the page.
        /// </param>
        protected override void OnNavigatedTo(NavigationEventArgs e)
        {
            base.OnNavigatedTo(e);

            var evt = e.Parameter as Event;
            vm.Id = evt.Id;
            vm.Name = evt.Name;
            vm.Description = evt.Description;
            vm.PictureNb = evt.PictureNb;
            vm.StartDate = evt.StartDate;
            vm.EndDate = evt.EndDate;
            vm.Pictures.Clear();
            evt.Pictures.ForEach(p => vm.Pictures.Add(p));
        }

        private async void initAsync(int id)
        {
            Waiter.Visibility = Visibility.Visible;
            RestResult<Event> ret = await RestApiManager.GetEvent(id);
            if (ret.IsSuccess)
            {
                var evt = ret.Data as Event;
                vm.Id = evt.Id;
                vm.Name = evt.Name;
                vm.Description = evt.Description;
                vm.PictureNb = evt.PictureNb;
                vm.StartDate = evt.StartDate;
                vm.EndDate = evt.EndDate;
                vm.Pictures.Clear();
                for (var i = 0; i < vm.PictureNb; i++)
                {
                    var number = i + 1;
                    RestResult<Picture> retPic = await RestApiManager.GetPicture(id, number);
                    Picture pic = null;
                    if (retPic.IsSuccess)
                    {
                        pic = retPic.Data;
                        pic.Number = number;
                    }
                    else {
                        pic = new Picture()
                        {
                            Id = number,
                            Eventt = evt,
                            Number = number,
                            FileName = "ERREUR " + number
                        };
                    }
                    vm.Pictures.Add(pic);
                }
                this.Page_Loaded(null, null);
                Waiter.Visibility = Visibility.Collapsed;
            }
            else
            {
                await new Windows.UI.Popups.MessageDialog(ret.ErrorMessage, ret.ErrorTitle).ShowAsync();
                Frame.GoBack();
            }
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            if (!string.IsNullOrEmpty(MyEvent._persistedPosition))
            {
                // Here we kick off the async function to use the saved string _persistedPosition and the function GetItem to restore the scroll posistion
                await ListViewPersistenceHelper.SetRelativeScrollPositionAsync(this.PicturesListView, MyEvent._persistedPosition, this.GetItem);
            }
        }

        protected override void OnNavigatingFrom(NavigatingCancelEventArgs e)
        {
            // Before we navigate away from the page, we want to generate a new _persistedPosition string. This string contains the key of the item at the top of the 
            // viewing window (generated by the function GetKey) and the offset of that item.
            MyEvent._persistedPosition = ListViewPersistenceHelper.GetRelativeScrollPosition(this.PicturesListView, this.GetKey);
            base.OnNavigatingFrom(e);
        }

        private void PicturesListView_ContainerContentChanging(ListViewBase sender, ContainerContentChangingEventArgs args)
        {
            // This function manually sets the height of the item ListViewPersistenceHelper is attempting to scroll to. We need to set the height
            // because if the item is not fully rendered at the time of scrolling, it can return an incorrect height and cause ListViewPersistenceHelper 
            // to overscroll. 
            var singleItem = args.Item as Picture;

            if (singleItem != null && singleItem.Id.ToString() == _persistedItemKey)
            {
                if (!args.InRecycleQueue)
                {
                    // Here we set the container's height equal to the fully rendered container height we had saved before navigating away. If all the items in 
                    // your list have the same fixed height, you can replace this variable with a hardcoded height value. 
                    args.ItemContainer.Height = _persistedItemContainerHeight;
                }
                else
                {
                    // Containers in a list are recycled when they are scrolled out of view. However, if those containers have their Height property set and the content
                    // changes, that set Height is still applied. This creates an incorect UI if the items in your list are supposed to be of variable height. 
                    // If all the items in your list have the same fixed height, you do not have to do this. 
                    args.ItemContainer.ClearValue(HeightProperty);
                }
            }
        }

        private void PicturesListView_ItemClick(object sender, ItemClickEventArgs e)
        {
            this.Frame.Navigate(typeof(PictureDisplay), e.ClickedItem);
        }

        private IAsyncOperation<object> GetItem(string key)
        {
            // This function takes a key that ListViewPersistenceHelper parsed out of the _persistedPosition string
            // It returns an item that corresponds to the given key
            // The implementation of this function is dependent on the data model you are using. Every item in your list should have
            // a unique key this function returns
            return Task.Run(() =>
            {
                if (vm.Pictures.Count <= 0)
                {
                    return null;
                }
                else
                {
                    return (object)vm.Pictures.FirstOrDefault(i => i.Id.ToString() == key);
                }
            }).AsAsyncOperation();
        }

        private string GetKey(object item)
        {
            // This function takes in the item at the top of the viewport at the moment of navigating away from the page, and returns
            // a key corresponding to that item. the implementation of this function is dependent on the data model you are using. In this 
            // function we also save the fully rendered _persistedItemContainerHeight. You do not need to do this if all of your items have 
            // the same fixed height. Finally, we save the key into a variable so it can be used outside of ListViewPersistenceHelper functions
            var singleItem = item as Picture;
            if (singleItem != null)
            {
                _persistedItemContainerHeight = (PicturesListView.ContainerFromItem(item) as ListViewItem).ActualHeight;
                _persistedItemKey = singleItem.Id.ToString();
                return _persistedItemKey;
            }
            else
            {
                return string.Empty;
            }
        }

    }
}
